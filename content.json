{"pages":[{"title":"About","text":"欢迎来到我的主页o(￣▽￣)ブ","link":"/about/index.html"},{"title":"","text":"","link":"/404.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"2022新年愿望，和女孩子说话不脸红","text":"&emsp;&emsp;下午去溜了好一会，从2点一直在街上溜达到下午5点多，走一会歇一会和朋友聊了很久，回家的路上越发地感觉应该写一点什么来整理一下我这一年以来的经历。其实这篇博客是除夕的晚上创建的，但是那晚什么都没写，也不知道该从哪里写起就睡觉去了，今晚打了一晚上的游戏，也打算写个开头就去睡觉了。2022-02-05 23:57:00 &emsp;&emsp;有些人总会像流星一样在那些平淡的日子里一闪而过，有幸能亲眼看到她的消逝，在我的心中留下一道永不会消逝的光芒,点缀着我的天空，照亮着我脚下的路。 &emsp;&emsp;昨晚偶然和一位许久没有联系的朋友聊了几句，说来奇怪，明明当初认识她的时候几乎无话不谈，现在却不知道怎么开口。细细算来，我们认识已经3年有余，她从高三到大三，我从大一到大四，她变成了学姐，我也变成了老学姐。时间有些长，以至于想起曾经做过的一些傻事现在只觉得意味深长。她告诉我这三年她过得很不错，打了比赛拿了奖，拿了奖学金，过了六级，预备党员，暑假到机关单位实习，不过还是抱怨“好累”，我相信她说的“累”是真的。她又问道我有没有收到什么上市公司的“橄榄枝”，我笑着说我去年一直在准备考研的事情根本没来得及投简历。看着她细数大学拿到的荣誉，我也在问自己这四年收获了些什么？四六级、省赛银奖、“碰瓷”可以勉强算上的国赛铜奖、在同行面前能勉强算是入门的专业技术、外人听起来很牛其实算不上什么的校企实践经历。这些零零碎碎的经历拼凑起来我的大学四年，最后几乎丝毫没有犹豫地选择了考研，如今坐在家里等待生死未卜的考试成绩。&emsp;&emsp;谈起考研，其实说不上什么远大的理想，就是希望能有个更好的平台和更好的文凭能够让我学到更多的知识，能够支撑着我亲手建造起属于自己的生活。有车有房，没有那么大的压力，希望朋友们也都能通过自己的努力过上好生活，偶尔和他们出去走一走逛一逛。更多的时间是和另一半待在一起，我们一起生活，宁静的下午我们慵懒地靠在一起聊着我们的过去和未来。如果能为集体，为社会做出一些贡献我当然是非常乐意的，只是就我个人的愿望而言，家庭和睦，物质生活富足就已经实我的梦中情生活了。关于以后留在什么地方工作，做什么样的工作，我有过一些考虑。如果能考上硕士，毕业后去大厂待几年如果薪水够我在当地买房那就选择定居，或者大厂不好混，那就靠着这张硕士文凭去做一名高校的老师，选择安稳的生活。如果很不幸我没有考上硕士，那就根据成绩的好坏判断是否还要二战的必要以及决定二战考哪里。说实话每次一想到自己很可能是没有希望考上的都会禁不住打一个寒颤，以后的打算摆在面前让我不寒而栗。可是现实是总归要面对的，读研，二战，工作，总要做出选择。 &emsp;&emsp;分手不是那么容易就能走得出来的。 &emsp;&emsp;这句话是我说的，或许也只是对我自己有效果。这次比上次带给我的冲击力要强上许多，可能是因为这件事情本身就比以往的要复杂许多。即便是快半年过去了，深夜也常感到孤独，晚上经常会梦到我们彼此解开了心结，冰释前嫌重归于好，或者梦到我们一拍两散，永不联系。我一直在感叹我这不平凡的经历，让我越发地确信我应该不会是一个平庸之辈。“平凡而不平庸”，我会平凡地活着，但我无法接收平庸的生活。昨晚出去跑了几公里，突然间的一瞬间感受到了一股前所未有的释然，最后冲刺的时候感受到了那种心无旁骛一心往前冲的感觉，我相信慢慢地肯定会走出来的。事业也好，爱情也罢，我绝不会逆来顺受，不会随波逐流，我要分析自己的问题，改正自己的错误，认识自己的软肋，找到自己的道路。毕竟每个人的追求都不同，只要敢于勇敢追求自己想要的生活，就是生活的勇者。 心怀期待的人还在等待 攒满失望的人早已离开 仍然自由自我 永远高唱我歌 走遍千里 console.log(\"永远年轻，\\n永远热泪盈眶\")","link":"/2022/02/02/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"title":"博客搭建完成","text":"第一次博客纪念 这是我的第一次博客，今天终于成功地用Hexo搭建起来一个个人博客。 ​ 最近在忙实验和项目， 事情还是不少的，下下来打算好好地复习一下功课，再研究点自己喜欢的小玩意。 计划邻近五一了，5天时间，本来打算去找可爱的，但是她要和家人出去玩，所以五一假期应该会有许多的空余 时间了。这段时间也可以利用起来，完善一下最近想做的一些事情。 复习硬件和算法 研究一下hexo，在github搭建一个完整的博客体系 做点小手工 ， 这也是我一直以来非常想做的事情 好久没有看英语了，得抓紧时间学英语 写一篇博客讲一讲自己搭建博客的经历 好好地看看数据库 最后一条：当然要和基友整一下大革命啦！","link":"/2020/04/05/My-first-post/"},{"title":"scrapy框架学习笔记","text":"scrapy框架 什么是框架 集成了很多功能，并且具有很强的通用性的项目模板 如何学习框架 什么是scrapy 爬虫中封装好的“明星”框架，封装程度高，使用频率高 功能： 高性能持久化存储 异步数据下载 高性能数据解析 分布式 基本使用 环境安装 mac、Linux: pip install scrapy windows: pip install wheel 下载安装twisted pip install pywin32 pip install scrapy 创建工程：scrapy startproject xxxPro 执行工程：scrapy crawl sipderName 数据解析 response.xpath() extract() extract_first() 持久化存储 基于终端指令： 要求：只可以将parse()方法的返回值存储到本地的文本文件中 步骤：将parse中需要存储的数据包装起来并作为返回值进入return 注意：持久化对应的文本文件类型只能是：json、csv、jl、jsonlines、marshal、pickle等 好处：简洁、高效、便捷 缺点：局限性强，数据只能存储为指定后缀的文本文件，且只能存储parse封装好的指定数据 基于管道： 编码流程： 数据解析 将解析的数据封装存储到item类型的对象 手动发送请求 yield scrapy.Request(url, callback) 五大核心组件 引擎（接收数据流&amp;触发事务） 引擎将请求对象发送给调度器的过滤器 从调度器的队列中获取请求对象并发送给下载器 将Response发送给Spider的parse 接受parse解析好的数据并发送给管道 爬虫类（Spider） 产生url，封装为请求对象发送给 引擎 ，并进行请求发送 调用parse进行数据解析并发送给引擎 管道 接收引擎发送的解析好的数据进行持久化存储 下载器 进行数据下载获取Response 提交Response至引擎 调度器 过滤器 对重复的请求对象进行去重，将去重后的请求对象发送到队列 队列问题：引擎是如何触发事务的？ 引擎通过接收到的不同数据流类型判断事务类型 请求传参 使用场景：爬取解析的数据不在同一张页面中。（深度爬取） 需求：爬取Boss直聘岗位名称与岗位描述 图片数据爬取之ImagesPipeline 基于字符串和基于图片的区别 字符串： 只需要基于xpath进行解析且提交管道并进行持久化 图片： xpath解析出图片src的属性值，单独对图片地址发起请求获取图片二进制类型的数据 ImagesPipeline: 只需要将img的src的属性值进行解析，提交到管道，管道就会对图片的src进行请求发送获取图片的二进制数据，且还会帮我们进行持久化存储 需求：爬取站长素材的高清图片 使用流程： 解析图片地址（懒加载） 将存储图片地址的item提交到指定的管道类 在管道文件中定制一个基于ImagesPipeline的管道类 get_media_request() file_path() item_completed() 在配置文件中： 指定文件存储目录: IMAGES_STORE = '[path]' 指定开启的管道： 自定制的管道类 遇到的问题： item提交给管道后，管道不接收图片，死活没有反应: INFO: Crawled 0 pages (at 0 pages/min), scraped 0 items (at 0 items/min) LOG_LEVEL = ‘DEBUG’后看到一条警告:WARNING: Disabled ImgsPipeline: ImagesPipeline requires installing Pillow 4.0.0 or later于是就赶紧安装了Pillow, 问题得以解决 中间件 爬虫中间件 下载中间件 位置：引擎和下载器之间 功能：批量拦截整个工程中所有的请求和响应 拦截请求： 进行UA伪装（可以对指定的请求进行专门的UA伪装） 代理IP的设定 拦截响应： 篡改响应数据、对象 需求：爬取网易新闻数据（标题+内容） 通过首页解析出五大板块对应详情页的URL（直接爬取） 板块对应的新闻标题列表（动态加载） 通过解析每一条新闻详情页URL，获取详情页源码解析出新闻内容（直接爬取）","link":"/2022/01/29/scrapy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"scrapy框架爬取网易新闻","text":"scrapy爬取网易新闻 使用scrapy爬取网易新闻的国内、国际、航空三个板块的新闻数据存储在csv中 初始化操作123scrapy startproject wangyiPro # 新建项目cd wangyiProscrapy genspider news # 创建爬虫 编写爬虫(news.py)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import scrapyfrom selenium.webdriver import Chrome, ChromeOptionsfrom wangyiPro.items import WangyiproItemimport reclass NewsSpider(scrapy.Spider): name = 'news' # allowed_domains = ['www.xxx.com'] start_urls = ['https://news.163.com/'] ''' 爬虫初始化阶段创建selenium无头浏览器实例用于获取动态加载的数据 ''' def __init__(self, **kwargs): super().__init__(**kwargs) options = ChromeOptions() options.add_experimental_option(&quot;excludeSwitches&quot;,['enable-automation']) # options.add_argument('--headless') 这两个是无头浏览器的选项 # options.add_argument('--disable-gpu') self.bro = Chrome(executable_path='D:\\\\Project\\\\python\\\\scrapy-test\\\\5.动态加载数据处理\\\\chromedriver.exe', chrome_options=options) # 解析五大板块对应详情页的url section_urls = [] # parse用于解析网易新闻的首页导航栏的对应板块url def parse(self, response): li_list = response.xpath('//*[@id=&quot;index2016_wrap&quot;]/div[3]/div[2]/div[2]/div[2]/div/ul/li') # with open('page.html', 'w', encoding='utf-8') as fp: # fp.write(response.text) index_list = [3, 6] # index_list = [2] # 板块url for index in index_list: name = li_list[index].xpath('./a/text()').extract_first() url = li_list[index].xpath('./a/@href').extract_first() item = { &quot;url&quot;: url, &quot;name&quot;: name } self.section_urls.append(item) # 依次对每个板块对应的页面进行请求 for item in self.section_urls: # print(url) yield scrapy.Request(url=item['url'], callback=self.parse_section, meta={&quot;url&quot;: item['url'], &quot;category&quot;: item['name']}) # 解析新闻标题和详情页url def parse_section(self, response): with open('./page.html', 'w', encoding='utf-8') as fp: fp.write(response.text) # 用于储存页面便于调试 div_list = response.xpath('//div[@class=&quot;ndi_main&quot;]/div') category = response.meta['category'] print(div_list[0]) for div in div_list: title = div.xpath('./div//h3/a/text()').extract_first() detail_url = div.xpath('./div//h3/a//@href').extract_first() print(title, detail_url) item = WangyiproItem() item['title'] = title item['category'] = category yield scrapy.Request(url=detail_url, callback=self.parse_detail, meta={&quot;item&quot;: item}) # 解析新闻数据 def parse_detail(self, response): ''' 这一部分是对新闻的内容、发布时间、来源做解析 内容获取后进行数据清晰，去掉空行、制表符等多余内容 ''' content = response.xpath('//*[@id=&quot;content&quot;]/div[2]').extract() content = ''.join(content) content = re.sub('\\n', '', content) content = re.sub('\\s', '', content) content = re.sub(' ', '', content) item = response.meta['item'] item['content'] = content ''' 发布时间的原始格式是&quot;\\n 2022-01-22 12:02:20 来源:&quot;,使用函数对时间部分进行提取 ''' timeline = response.xpath('//div[@class=&quot;post_info&quot;]/text()').extract_first() timeline = timeline.split('来源')[0] timeline = re.findall(pattern=r'20?.* ?.*:[0-9]{2}', string=timeline)[0] item['timeline'] = timeline item['origin'] = response.xpath('//*[@id=&quot;container&quot;]/div[1]/div[2]/a/text()').extract_first() # print(item) yield item def closed(spider, reason): spider.bro.quit() pass items.py12345678910import scrapyclass WangyiproItem(scrapy.Item): # 标题、内容、来源、发布时间、分类 title = scrapy.Field() content = scrapy.Field() origin = scrapy.Field() timeline = scrapy.Field() category = scrapy.Field() 中间件middleware.py 中间件部分主要用于处理新闻板块的新闻列表部分是动态加载出来的，所以在这里使用selenium将获取到的动态加载数据替换原先下载器获取的数据，然后发送给引擎处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Define here the models for your spider middlewareimport timefrom scrapy import signalsfrom scrapy.http import HtmlResponse# useful for handling different item types with a single interfacefrom itemadapter import is_item, ItemAdapterclass WangyiproDownloaderMiddleware(object): # Not all methods need to be defined. If a method is not defined, # scrapy acts as if the downloader middleware does not modify the # passed objects. def process_request(self, request, spider): # Called for each request that goes through the downloader # middleware. # print('request middleware') # Must either: # - return None: continue processing this request # - or return a Response object # - or return a Request object # - or raise IgnoreRequest: process_exception() methods of # installed downloader middleware will be called return None # 拦截板块详情页响应对象，修改为符合需求的对象 def process_response(self, request, response, spider): # 获取在爬虫中定义的浏览器对象 print('开始拦截...') bro = spider.bro urls = [] for url in spider.section_urls: urls.append(url['url']) # Called with the response returned from the downloader. # 筛选对应的响应对象 if request.url in urls: # response 板块详情页响应对象 # 实例化新的响应对象，包含动态加载的数据 ''' 如何获取动态加载的响应数据？ selenium ''' bro.get(url=request.url) bro.implicitly_wait(30) # 隐形等待最长30s # time.sleep(4) page_text = bro.page_source # 获取动态加载的新闻数据 new_res = HtmlResponse(url=request.url, body=page_text, encoding='utf-8', request=request) return new_res else: print('Middleware no filter:', request.url) return response def process_exception(self, request, exception, spider): # Called when a download handler or a process_request() # (from other downloader middleware) raises an exception. # Must either: # - return None: continue processing this exception # - return a Response object: stops process_exception() chain # - return a Request object: stops process_exception() chain return None 管道pipelines.py 用于持久化存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Define your item pipelines here## Don't forget to add your pipeline to the ITEM_PIPELINES setting# See: https://docs.scrapy.org/en/latest/topics/item-pipeline.html# useful for handling different item types with a single interfaceimport csvimport osfrom itemadapter import ItemAdapterclass WangyiproPipeline: def __init__(self): # 如果文件不存在就新建文件 # 这里参考了https://www.cnblogs.com/shawone/p/10228912.html if not os.path.exists('./news.csv'): # 打开文件，指定方式为写，利用第3个参数把csv写数据时产生的空行消除 self.f = open(&quot;news.csv&quot;, &quot;a&quot;, newline=&quot;&quot;, encoding='utf-8') # 设置文件第一行的字段名，注意要跟spider传过来的字典key名称相同 self.fieldnames = [&quot;title&quot;, &quot;content&quot;, &quot;origin&quot;, &quot;timeline&quot;, &quot;category&quot;] # 指定文件的写入方式为csv字典写入，参数1为指定具体文件，参数2为指定字段名 self.writer = csv.DictWriter(self.f, fieldnames=self.fieldnames) # 写入第一行字段名，因为只要写入一次，所以文件放在__init__里面 self.writer.writeheader() else: self.f = open(&quot;news.csv&quot;, &quot;a&quot;, newline=&quot;&quot;, encoding='utf-8') self.fieldnames = [&quot;title&quot;, &quot;content&quot;, &quot;origin&quot;, &quot;timeline&quot;, &quot;category&quot;] self.writer = csv.DictWriter(self.f, fieldnames=self.fieldnames) ''' 重写父类方法 该仅仅在爬虫开始时调用一次 ''' def open_spider(self, spider): pass def process_item(self, item, spider): self.writer.writerow(item) return item # 传递给下一个执行的管道类 def close_spider(self, spider): print('结束爬虫...') self.f.close() 项目配置settings.py 这是坑比较多的一部分 UA伪装与代理IP123# 由于网易没有太复杂的校验，所有我的全部请求使用的一样的请求头# Crawl responsibly by identifying yourself (and your website) on the user-agentUSER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.99 Safari/537.36' 另外代理IP可以在中间件中的downloader类中的process_exception函数中做判断并设置代理IP 123456789101112131415# 拦截发生异常的请求 def process_exception(self, request, exception, spider): # Called when a download handler or a process_request() # (from other downloader middleware) raises an exception. # 代理 if request.split(':')[0]=='http': request.meta['proxy'] = 'http://'+ random.choice(self.proxy_http) else: request.meta['proxy'] = 'http://'+ random.choice(self.proxy_https) # Must either: # - return None: continue processing this exception # - return a Response object: stops process_exception() chain # - return a Request object: stops process_exception() chain return request 最后就是一些常见配置 12345678910111213141516171819# Obey robots.txt rulesROBOTSTXT_OBEY = FalseLOG_LEVEL = 'ERROR'# Enable or disable downloader middlewares# 这里有个很坑的地方是关于中间件，下载中间件和爬虫中间件的配置是在两个不同的地方，我们只需要开启下载中间件就可以了。第一次使用的时候没有看清开启的是SPIDER_MIDDLEWARES，还特意把WangyiproSpiderrMiddleware换成WangyiproDownloaderMiddleware因此走了很多弯路，导致中间件调试了很久都不起作用，我还以为我电脑坏了。SPIDER_MIDDLEWARES = {# 'wangyiPro.middlewares.WangyiproSpiderrMiddleware': 543, 'wangyiPro.middlewares.WangyiproDownloaderMiddleware': 543,}DOWNLOADER_MIDDLEWARES = { 'wangyiPro.middlewares.WangyiproDownloaderMiddleware': 543,}# Configure item pipelinesITEM_PIPELINES = { 'wangyiPro.pipelines.WangyiproPipeline': 300,} 关于调试main.py&emsp;&emsp;起初运行爬虫都是在控制台中用scrapy命令，但是这样就无法让IDE中的断点生效从而无法调试，后来参考了https://www.cnblogs.com/weixuqin/p/9074448.html, 在项目的根目录创建main.py，写入以下内容后右键debug开启了调试功能 1234567891011#!/usr/bin/env python#-*- coding:utf-8 -*-from scrapy.cmdline import executeimport osimport sys#添加当前项目的绝对地址sys.path.append(os.path.dirname(os.path.abspath(__file__)))#执行 scrapy 内置的函数方法execute， 使用 crawl 爬取并调试，最后一个参数news 是我的爬虫文件名execute(['scrapy', 'crawl', 'news']) 最终结果","link":"/2022/01/29/scrapy%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB/"},{"title":"vue-双向数据绑定","text":"vue双向数据绑定demo 参考B站up蛋老师是的视频学习了一下vue的双向数据绑定以及模板解析的操作，实在是太巧妙了！视频地址 &emsp;&emsp;直接放代码，前端部分，参考vue的写法，这里的data是一个普通的对象，vue官网的data是一个函数，官方的写法应该是为了数据绑定做出的优化，但是没有了解过相关原理，所有暂时还不太理解二者的区别。 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;label&gt;用户名： &lt;input v-model=&quot;name&quot; type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; &lt;/label&gt;&lt;br&gt; &lt;label&gt;年&amp;emsp;龄： &lt;input v-model=&quot;info.age&quot; type=&quot;text&quot; name=&quot;age&quot; id=&quot;age&quot;&gt; &lt;/label&gt;&lt;br&gt; &lt;label&gt;身&amp;emsp;高： &lt;input v-model=&quot;info.height&quot; type=&quot;text&quot; name=&quot;height&quot; id=&quot;height&quot;&gt; &lt;/label&gt; &lt;p&gt; 用户名： {{ name }} &lt;/p&gt; &lt;p&gt;年龄： {{info.age}}&lt;/p&gt; &lt;p&gt;身高： {{info.height}}cm&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt; const vm = new Vue({ el: &quot;#app&quot;, data: { name: &quot;啦啦啦种太阳&quot;, info: { age: 18, height: 170 } } })&lt;/script&gt; HTML部分参考官方的写法，本次的demo主要实现文本渲染、输入框的v-model监听，以及数据绑定 JS部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// vue.jsclass Vue { constructor({el, data}) { this.$el = el this.$data = data Observer(this.$data) Compile(el, this) }}// 为数据绑定监听者function Observer(data_instance) { if(!data_instance || typeof data_instance !== 'object') return; const dependency = new Dependency(); Object.keys(data_instance).forEach(key =&gt; { let value = data_instance[key] Observer(value) Object.defineProperty(data_instance, key, { enumerable: true, configurable: true, get() { console.log(`访问了属性：${key} -&gt; 值 ${value}`) Dependency.temp &amp;&amp; dependency.addSub(Dependency.temp) if(Dependency.temp) console.log(Dependency.temp) return value; }, set(newValue) { console.log(`属性${key}的值&quot;${value}&quot;修改为 -&gt; &quot;${newValue}&quot;`) value = newValue Observer(newValue) dependency.notify() } }) })}// 模板解析function Compile(element, vm) { vm.$el = document.querySelector(element); const fragment = document.createDocumentFragment(); let child; while(child = vm.$el.firstChild) { fragment.append(child) } fragment_compile(fragment) function fragment_compile(node) { const pattern = /\\{\\{\\s*(\\S+)\\s*\\}\\}/ if(node.nodeType === 3) { const xxx = node.nodeValue const result = pattern.exec( node.nodeValue) if(result) { const arr = result[1].split(&quot;.&quot;) const value = arr.reduce((total, current) =&gt; total[current], vm.$data) node.nodeValue = xxx.replace(pattern, value) new Watcher(vm, result[1], newValue =&gt; { node.nodeValue = xxx.replace(pattern, newValue) }) } return } // 实现input框的v-model属性绑定 if(node.nodeType === 1 &amp;&amp; node.nodeName === &quot;INPUT&quot;) { const attr = Array.from(node.attributes) attr.forEach(i =&gt; { if(i.nodeName === 'v-model') { const value = i.nodeValue.split(&quot;.&quot;).reduce( (total, current) =&gt; total[current], vm.$data ) node.value = value new Watcher(vm, i.nodeValue, newValue =&gt; { node.value = newValue }) node.addEventListener('input', e =&gt; { let name = i.nodeValue.split(&quot;.&quot;); const final = name.slice(0, name.length - 1).reduce( (total, current) =&gt; total[current], vm.$data ) final[name[name.length - 1]] = e.target.value }) } }) } node.childNodes.forEach(child =&gt; fragment_compile(child)) } vm.$el.append(fragment)}/**发布订阅模式 */class Dependency { temp = null constructor() { this.subscriber = [] } addSub(sub) { this.subscriber.push(sub) } notify() { this.subscriber.forEach(sub =&gt; sub.update()) }}// 观察者class Watcher { constructor(vm, key, callback) { this.vm = vm this.key = key this.callback = callback // 临时属性 触发getter Dependency.temp = this console.log(`用属性${key}创建了订阅者`) key.split(&quot;.&quot;).reduce((total, current) =&gt; total[current], vm.$data) // 触发属性的getter Dependency.temp = null } update() { const value = this.key.split(&quot;.&quot;).reduce((total, current) =&gt; total[current], this.vm.$data) this.callback(value) }} &emsp;&emsp;视频看了两遍，全程跟着敲，第一遍还不太理解Watcher类是如何绑定对于数据的监听的，而且不太理解getter和setter的触发的巧妙之处。&emsp;&emsp;Watcher其实就是在虚拟dom添加至页面的时候，将每一个在页面中要被渲染的值进行监听。监听的本质就是将data中的一个值于Watcher的一个实例对象所提供的callback函数绑定在一起，每当setter函数被触发，及data中的值发生了改变，则调用callback函数。Dependency类中存储了所有的Watcher实例，此处demo中对于通知Watcher进行更新的方法是，一旦setter被触发就通知Dependency.subscriber中的所有watcher进行更新，Watcher实例自带的update函方法可以找到自己正在监听的数据，并从根实例vm中获取最新的数据值并调用自身的callback函数。callback是在解析数据的同时对Watcher实例化的时候传入的，所以callback可以直接访问到数据要解析的目标dom，当Watcher接收到了新的值，就可以直接对dom进行重新渲染，也就实现了所谓的“双向绑定”。","link":"/2022/05/05/vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"title":"selenium模拟12306登录","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import timefrom selenium import webdriverfrom lxml import etreefrom selenium.webdriver import ActionChains, ChromeOptions as Optionsfrom selenium.webdriver.common.by import Byjs = 'return window.navigator.webdriver'''' 实现无可视化界面'''options = Options()# options.add_argument('--headless')# options.add_argument('--disable-gpu')''' 实现规避检测'''option_avoid = Options()option_avoid.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_experimental_option('useAutomationExtension', False)bro = webdriver.Chrome(chrome_options=options, options=option_avoid)# 12306会通过获取window.navigator.webdriver属性判断是否为模拟浏览器# 在加载阶段调用cdp(Chrome Devtool Protocol)抹掉该属性bro.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, { &quot;source&quot;: &quot;&quot;&quot; Object.defineProperty(navigator, 'webdriver', { get: () =&gt; undefined }) &quot;&quot;&quot;})bro.get('https://kyfw.12306.cn/otn/resources/login.html')username_input = bro.find_element(By.ID, 'J-userName')password_input = bro.find_element(By.ID, 'J-password')username_input.send_keys('用户名xxxxx')password_input.send_keys('密码xxxxx')login_btn = bro.find_element(By.ID, 'J-login')login_btn.click()slide_modal = bro.find_element(By.ID, 'modal')bro.execute_script('document.title =&quot;测试&quot;')bro.execute_script('document.body.appendChild(document.createElement(\\'div\\'))')time.sleep(2)print(bro.execute_script(js))with open('./login.html', 'w', encoding='utf-8') as fp: fp.write(bro.page_source)while True: try: action = webdriver.ActionChains(bro) # 利用行为链，持续按住并拖拽 span = bro.find_element(By.ID, 'nc_1_n1z') # 获取滑块 action.drag_and_drop_by_offset(span, 330, 0).perform() # 按住并拖动 &gt;300px即可，选用330绰绰有余 # action.click_and_hold(span).perform() # action.move_by_offset(xoffset=300,yoffset=0).perform() 另一张拖动 action.release() # 释放 print(bro.execute_script(js)) time.sleep(2) a = bro.find_element(By.ID, 'nc_1_refresh1') # 查找刷新按钮，如果没有说明登录成功，执行except跳出循环 a.click() # 如果刚刚滑动失败，则点击刷新，重新滑动 time.sleep(4) except Exception as e: print(e) break","link":"/2022/01/28/selenium%E6%A8%A1%E6%8B%9F12306%E7%99%BB%E5%BD%95/"},{"title":"我喜欢过两个女孩，一个是你，另一个也是你","text":"遗憾没有早早遇见，与你之间错过了许多年。 小时候不懂鲁迅所说的：“我们家有两棵树，一颗是枣树，另一颗也是枣树。”直到经历了一些事情，才渐渐地明白了此中的深意。 煙雨行舟卻不知舟在何處 唱着年少有爲的人終究是負了佳人 “誰能憑愛意要富士山私有” 本就無法打動的人 憑你再用盡心機又如何 我的愛像塵埃 何謂小恩 何謂小惠 何謂大恩 何謂大德 再微不得到的小惠也能變成大恩 只是你放下了手裡的放大鏡 沒有誰對誰錯 只有愛與不愛 這世界還是一片光亮 我要帶你到處去飛翔 你不再是我的專屬 你的裙擺 你的衣角 你的薄脣 你的眉眼 看着都有種別樣的心酸 不過還好 慢慢地放下 舊的總要走 新的總要來 不過我是個深情的人 枯死的還能張處新芽 我靜靜地蹲在花盆前爲枯死的小花澆水 我想象着小花復甦後我欣喜若狂的樣子 有人勸我不如再摘一株小花 一樣美麗 一樣芬芳 但 總歸不是這一株小花 我也早已失去了種花的本事","link":"/2020/08/05/%E6%88%91%E5%96%9C%E6%AC%A2%E8%BF%87%E4%B8%A4%E4%B8%AA%E5%A5%B3%E5%AD%A9%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%98%AF%E4%BD%A0%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E4%B9%9F%E6%98%AF%E4%BD%A0/"},{"title":"临江仙·夜饮东坡醒复醉 苏轼","text":"夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。 长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。","link":"/2022/01/26/%E4%B8%B4%E6%B1%9F%E4%BB%99%C2%B7%E5%A4%9C%E9%A5%AE%E4%B8%9C%E5%9D%A1%E9%86%92%E5%A4%8D%E9%86%89/"},{"title":"生与死","text":"图书馆前的林荫路上有许多石凳 我一个一个地坐过去 每次坐下没过一会 我都会忍不住看向下一个凳子 总觉得下面的那一条才是我们那天坐的 我大约是找到了那天的凳子 也可能是弄丢了你-","link":"/2020/07/27/%E7%9F%B3%E5%87%B3/"},{"title":"浮世三千","text":"I love three things in the worldThe sun, The moon, and youSun for the morningMoon for the nightAnd you, forever 浮世三千 吾爱有三 日， 月， 与卿 日为朝 月为暮 卿为朝朝暮暮","link":"/2020/07/25/%E6%B5%AE%E4%B8%96%E4%B8%89%E5%8D%83/"},{"title":"罗老师百大发言","text":"&emsp;&emsp;我们注定无法生活在凡事都安排好的幻觉之中，人生中很多重要的时刻常常不期而至，所以人生唯一确定的也许就是不确定的人生。在英文中，“今天”也意外着礼物“present”，而在中文中，“今”与命令的“令”很相似，所以我把今天既看做礼物又看做命令，需要一点一点过好，完成每天的命令。当我们忠于每个今天的命令，我们就能从容面对每个神秘莫测的明天。明天并不可控，但我们可以选择乐观以待，让我们以感恩的心演好每个今天的剧本，超越我们有限的今生。","link":"/2022/01/30/%E7%BD%97%E8%80%81%E5%B8%88%E7%99%BE%E5%A4%A7%E5%8F%91%E8%A8%80/"},{"title":"洗牌算法","text":"基本原理 洗牌算法是一种将一组数据随机排列的算法，保证每一个元素重新被分配到任何一个位置上的几率都是均等的，是保证随机程度的关键。 每次随机选取一个数，然后将该数与数组中最后(或最前)的元素相交换(如果随机选中的是最后/最前的元素，则相当于没有发生交换)；然后缩小选取数组的范围，去掉最后的元素,即之前随机抽取出的数。重复上面的过程，直到剩余数组的大小为1，即只有一个元素时结束。 完整代码12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;洗牌算法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] document.writeln(arr) document.writeln(&quot;&lt;p&gt;洗牌算法=&gt;&lt;/p&gt;&quot;) function pockerAlgorithm(arr) { let len = arr.length arr.forEach((item, index) =&gt; { let max = len - index - 1 // cal max position let pos = Math.floor(Math.random() * (max + 1)) console.log(max + &quot; &quot; + pos) let temp = arr[pos] arr[pos] = arr[max] arr[max] = temp }) return arr } document.writeln(pockerAlgorithm(arr) + &quot;&lt;br&gt;&quot;) document.writeln(pockerAlgorithm(arr) + &quot;&lt;br&gt;&quot;) document.writeln(pockerAlgorithm(arr) + &quot;&lt;br&gt;&quot;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/12/29/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"},{"title":"老男孩","text":"这辈子也不会这么迷茫了 “那是我日夜思念深深爱着的人呐，到底我该如何表达，她会接受我吗？” 最近尤其喜欢这首歌，大概是歌词里面凡是带“她”的我都喜欢吧。大学生涯以来最困扰我的问题竟然不是写不出好的程序，我也是奇了怪了。 说再多的话也无济于事，可能这是我自己独有的属性，脑子里的想法就像波澜的海面，原本平静的海面不知何时就会泛起一阵涟漪。我的内心总是不平静的，嘴上总说着“没事没事，就是发会呆”，不过是不愿往深处想罢了，越往深处想，心里越堵得慌。曾经嘲笑别人输给了爱情，结果自己也陷了进去，无法自拔，不过是不愿往深处想罢了，越往深处想，心里越堵得慌。曾经嘲笑别人输给了爱情，结果自己也陷了进去，无法自拔。。","link":"/2020/07/25/%E8%80%81%E7%94%B7%E5%AD%A9/"},{"title":"裤子","text":"略","link":"/2020/05/27/%E8%A3%A4%E5%AD%90/"}],"tags":[{"name":"Heart","slug":"Heart","link":"/tags/Heart/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"scrapy","slug":"scrapy","link":"/tags/scrapy/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"网易新闻","slug":"网易新闻","link":"/tags/%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"selenium","slug":"selenium","link":"/tags/selenium/"},{"name":"诗词","slug":"诗词","link":"/tags/%E8%AF%97%E8%AF%8D/"},{"name":"人生","slug":"人生","link":"/tags/%E4%BA%BA%E7%94%9F/"},{"name":"heart","slug":"heart","link":"/tags/heart/"},{"name":"Soul","slug":"Soul","link":"/tags/Soul/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"洗牌算法","slug":"洗牌算法","link":"/tags/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}